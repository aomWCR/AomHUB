local Rawr = {}
local Api = {}
local Log = {}

local function Service(name)
	return game:GetService(name)
end

local function SecondsToClock(seconds)
	-- https://gist.github.com/jesseadams/791673
	local seconds = tonumber(seconds)
	if seconds <= 0 then
		return "00:00:00";
	else
		local hours = string.format("%02.f", math.floor(seconds/3600));
		local mins = string.format("%02.f", math.floor(seconds/60 - (hours*60)));
		local secs = string.format("%02.f", math.floor(seconds - hours*3600 - mins *60));
		return hours..":"..mins..":"..secs
	end
end

function Log:Init()
	local Profile = game:GetService("ReplicatedStorage").Profiles[Api.GetPlayer().Name]
	local Vel = Profile.Stats.Vel
	local LastVel = Vel.Value
	Log.Earned = {
		Vel = 0,
		Items = {},
	}
	Profile.Inventory.ChildAdded:Connect(function(item)
		table.insert(Log.Earned.Items, item.Name)
		if(Api.GetSetting("auto_dismantle") == true)then
			Api.Dismantle(item.Name)
		end
	end)
	Vel.Changed:Connect(function()
		local earn = Vel.Value - LastVel
		LastVel = Vel.Value
		Log.Earned.Vel = Log.Earned.Vel + earn
	end)
end

function Log.Save()
	Log.Earned.RunTime = SecondsToClock(tick()-Api.Start)
end

function Rawr:Check(...) --secret sauce
	local player = Api.GetPlayer()
	local character = Api.GetCharacter()
	local args = {...}
	
	if(character and character.PrimaryPart and args[1]:lower()=="cframe")then
		--player.Character = Api.FakeCharacter
		player.Character.RobloxLocked = true
		wait(Api.GetSetting("rawr_bypass_speed"))
		character:SetPrimaryPartCFrame(args[2])
		wait(Api.GetSetting("rawr_bypass_speed"))
		--player.Character = character
		player.Character.RobloxLocked = false
	end
end

function Api.GetPlayer()
	return game:GetService("Players").LocalPlayer
end

function Api.Dismantle(name)
	game.ReplicatedStorage.Event:FireServer("Equipment", {
		"Dismantle",
		game:GetService("ReplicatedStorage").Profiles[Api.GetPlayer().Name].Inventory[name]
	})
end

function Api.Replicate(object)
	local Model = Instance.new("Model")
	Model.Name = object.Name
	for index, child in pairs(object:GetChildren()) do
		local c = child:Clone()
		c.Parent = Model
	end
	if(object.PrimaryPart)then
		Model.PrimaryPart = Model[object.PrimaryPart.Name]
	end
	return Model
end

function Api.GetCharacter()
	return Api.Character or Api.GetPlayer().Character
end

function Api.GetEntity(model)
	return model:FindFirstChild("Entity")
end

function Api.Settings(...)
	Api.Settings = {}
	for name, value in pairs(...) do
		Api.Settings[name] = value
	end
end

function Api.GetSetting(name)
	return Api.Settings[name]
end

function Api.IsValid(model)
	if(model.PrimaryPart and model:FindFirstChild("Entity") and model.Entity:FindFirstChild("Health") and model.Parent~=nil and model:FindFirstChild("Nameplate"))then
		return true
	end
end

function Api.GetPlayerDistances(model)
	local localPlayer = Api.GetPlayer()
	local distances = {}
	for index, player in pairs(Service("Players"):GetChildren()) do
		if(player~=localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and model:FindFirstChild("HumanoidRootPart"))then
			distances[player.Name] = (model.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).magnitude
		end
	end
	return distances
end

function Api.CheckNear(monster)
	if(Api.GetSetting("avoid_players_nearby")["Enabled"] == true)then
		local max_distance = Api.GetSetting("avoid_players_nearby")["Distance"]
		local distances = Api.GetPlayerDistances(monster)
		for player, distance in pairs(distances)do
			if(distance <= max_distance)then
				return false
			end
		end
	end
	return true
end

function Api.CheckBlacklist(monster)
	for index, blacklist in pairs(Api.Blacklist) do
		if(monster == blacklist)then
			return false
		end
	end
	return true
end

function Api.GetMonsters()
	local targets = {}
	for index, monster in pairs(Service("Workspace").Mobs:GetChildren()) do
		local entity = monster:FindFirstChildOfClass("Folder")
		local filterApplied = false
		local distanceCheck = Api.CheckNear(monster)
		if(monster.PrimaryPart and Api.IsValid(monster) and distanceCheck and Api.CheckBlacklist(monster))then
			if(Api.GetSetting("monster_filter")["Enabled"] == true)then
				if(entity.Health.Value >= Api.GetSetting("monster_filter")["max_monster_health"] and entity.Exp.Value >= Api.GetSetting("monster_filter")["min_exp_earned"])then
					table.insert(targets, monster)
				end
				filterApplied = true
			elseif(Api.GetSetting("target_specific_enemy").Enabled == true)then
				if(Api.GetSetting("target_specific_enemy").Names[monster.Nameplate.SurfaceGui.TextLabel.Text] == true)then
					table.insert(targets, monster)
				end
				filterApplied = true
			end
			if(filterApplied == false)then
				table.insert(targets, monster)
			end
		end
	end
	return targets
end

function Api:Connect()
	local player = Api.GetPlayer()
	local character = Api.GetCharacter()
	local setupCharacter = function(character)
		Api.FakeCharacter = Api.Replicate(character)
	end
	
	setupCharacter(character)
	player.CharacterAdded:Connect(setupCharacter)
end

function Tlprt(a,b,c)
	local d=game:GetService("TweenService")
	local e=TweenInfo.new(30,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,0,false,0)
	local f={CFrame=CFrame.new(a,b,c)}
	local g=d:Create(game.Players.LocalPlayer.Character.HumanoidRootPart,e,f)
	g:Play()
end;

function Api:Init()
	Api.Blacklist = {}
	Api.Start = tick()
	Api.Paused = false
	Api.CanClick = false
	wait(Api.GetSetting("StartDelay"))
	while wait() and Api.Enabled do
		if(Api.Paused == false)then
			for index, monster in pairs(Api.GetMonsters()) do
				local distanceCheck = Api.CheckNear(monster)
				if(distanceCheck and Api.IsValid(monster) and Api.Enabled)then -- recheck
					wait(Api.GetSetting("swap_monster_speed"))
					local entity = Api.GetEntity(monster)
					local base = entity.Health.Value
					entity.Health.Changed:Connect(function()
						if(entity.Health.Value == base)then
							dontBreak = false
						end
					end)
					dontBreak = true
					local timer = 0
					while dontBreak and Api.Enabled do
						if(Api.Paused == false)then
							local thisTime = wait()
							wait(thisTime)
							timer = timer + thisTime
							if(timer >= Api.GetSetting("timeout")["time"])then
								warn('Timeout exceeded!')
								if(Api.GetSetting("timeout")["blacklist_monster_after_timeout"] == true)then
									table.insert(Api.Blacklist, monster)
								end
								break
							end
							if(Api.IsValid(monster) and entity.Health.Value > 0)then
								local character = Api.GetCharacter()
								if(character)then
									Api.CanClick = true
									Tlprt(monster["HumanoidRootPart"].Position.X, -5, monster["HumanoidRootPart"].Position.Z)--monster["HumanoidRootPart"].Position.Y
								else
									character = Api.GetCharacter()
									if(character)then
										Tlprt(monster["HumanoidRootPart"].Position.X, -5, monster["HumanoidRootPart"].Position.Z) --monster["HumanoidRootPart"].Position.Y
										wait(Api.GetSetting("swap_monster_speed"))
									end
								end
							else
								Api.CanClick = false
								break
							end
						else
							wait()
						end
					end
					wait(Api.GetSetting("swap_monster_speed"))
				end
			end
		end
	end
	Log.Save()
end

Api.Settings({
	["start_delay"] = 2,
	["rawr_bypass_speed"] = 0.5, -- 0.65
	["swap_monster_speed"] = 0.2, -- 0.7,
	["click_break_speed"] = .01,
	["auto_dismantle"] = false,
	["timeout"] = {
		["time"] = 15,
		["blacklist_monster_after_timeout"] = true
	},
	["monster_filter"] = {
		["Enabled"] = false,
		["max_monster_health"] = 0,
		["min_exp_earned"] = 0,
	},
	["avoid_players_nearby"] = {
		["Enabled"] = true,
		["Distance"] = 200
	},
	["target_specific_enemy"] = {
		["Enabled"] = false,
		["Names"] = {
			["Giant Ruins Hornet"] = false,
			["Enraged Lingerer"] = true,
			["Undead Berserker"] = true,
			["Undead Warrior"] = true,
			["Gargoyle Reaper"] = false,
			["Mortis the Flaming Sear"] = false,
		}
	}
})	
Api:Connect()
Log:Init()
Api:Init()
Api.Enabled = false
Api.Paused = true
Api.Paused = false

return Api
